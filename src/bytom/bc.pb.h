// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bc.proto

#ifndef PROTOBUF_bc_2eproto__INCLUDED
#define PROTOBUF_bc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_bc_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[17];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsHashImpl();
void InitDefaultsHash();
void InitDefaultsProgramImpl();
void InitDefaultsProgram();
void InitDefaultsAssetIDImpl();
void InitDefaultsAssetID();
void InitDefaultsAssetAmountImpl();
void InitDefaultsAssetAmount();
void InitDefaultsAssetDefinitionImpl();
void InitDefaultsAssetDefinition();
void InitDefaultsValueSourceImpl();
void InitDefaultsValueSource();
void InitDefaultsValueDestinationImpl();
void InitDefaultsValueDestination();
void InitDefaultsBlockHeaderImpl();
void InitDefaultsBlockHeader();
void InitDefaultsTxHeaderImpl();
void InitDefaultsTxHeader();
void InitDefaultsTxVerifyResultImpl();
void InitDefaultsTxVerifyResult();
void InitDefaultsTransactionStatusImpl();
void InitDefaultsTransactionStatus();
void InitDefaultsMuxImpl();
void InitDefaultsMux();
void InitDefaultsCoinbaseImpl();
void InitDefaultsCoinbase();
void InitDefaultsOutputImpl();
void InitDefaultsOutput();
void InitDefaultsRetirementImpl();
void InitDefaultsRetirement();
void InitDefaultsIssuanceImpl();
void InitDefaultsIssuance();
void InitDefaultsSpendImpl();
void InitDefaultsSpend();
inline void InitDefaults() {
  InitDefaultsHash();
  InitDefaultsProgram();
  InitDefaultsAssetID();
  InitDefaultsAssetAmount();
  InitDefaultsAssetDefinition();
  InitDefaultsValueSource();
  InitDefaultsValueDestination();
  InitDefaultsBlockHeader();
  InitDefaultsTxHeader();
  InitDefaultsTxVerifyResult();
  InitDefaultsTransactionStatus();
  InitDefaultsMux();
  InitDefaultsCoinbase();
  InitDefaultsOutput();
  InitDefaultsRetirement();
  InitDefaultsIssuance();
  InitDefaultsSpend();
}
}  // namespace protobuf_bc_2eproto
namespace bc {
class AssetAmount;
class AssetAmountDefaultTypeInternal;
extern AssetAmountDefaultTypeInternal _AssetAmount_default_instance_;
class AssetDefinition;
class AssetDefinitionDefaultTypeInternal;
extern AssetDefinitionDefaultTypeInternal _AssetDefinition_default_instance_;
class AssetID;
class AssetIDDefaultTypeInternal;
extern AssetIDDefaultTypeInternal _AssetID_default_instance_;
class BlockHeader;
class BlockHeaderDefaultTypeInternal;
extern BlockHeaderDefaultTypeInternal _BlockHeader_default_instance_;
class Coinbase;
class CoinbaseDefaultTypeInternal;
extern CoinbaseDefaultTypeInternal _Coinbase_default_instance_;
class Hash;
class HashDefaultTypeInternal;
extern HashDefaultTypeInternal _Hash_default_instance_;
class Issuance;
class IssuanceDefaultTypeInternal;
extern IssuanceDefaultTypeInternal _Issuance_default_instance_;
class Mux;
class MuxDefaultTypeInternal;
extern MuxDefaultTypeInternal _Mux_default_instance_;
class Output;
class OutputDefaultTypeInternal;
extern OutputDefaultTypeInternal _Output_default_instance_;
class Program;
class ProgramDefaultTypeInternal;
extern ProgramDefaultTypeInternal _Program_default_instance_;
class Retirement;
class RetirementDefaultTypeInternal;
extern RetirementDefaultTypeInternal _Retirement_default_instance_;
class Spend;
class SpendDefaultTypeInternal;
extern SpendDefaultTypeInternal _Spend_default_instance_;
class TransactionStatus;
class TransactionStatusDefaultTypeInternal;
extern TransactionStatusDefaultTypeInternal _TransactionStatus_default_instance_;
class TxHeader;
class TxHeaderDefaultTypeInternal;
extern TxHeaderDefaultTypeInternal _TxHeader_default_instance_;
class TxVerifyResult;
class TxVerifyResultDefaultTypeInternal;
extern TxVerifyResultDefaultTypeInternal _TxVerifyResult_default_instance_;
class ValueDestination;
class ValueDestinationDefaultTypeInternal;
extern ValueDestinationDefaultTypeInternal _ValueDestination_default_instance_;
class ValueSource;
class ValueSourceDefaultTypeInternal;
extern ValueSourceDefaultTypeInternal _ValueSource_default_instance_;
}  // namespace bc
namespace bc {

// ===================================================================

class Hash : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.Hash) */ {
 public:
  Hash();
  virtual ~Hash();

  Hash(const Hash& from);

  inline Hash& operator=(const Hash& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Hash(Hash&& from) noexcept
    : Hash() {
    *this = ::std::move(from);
  }

  inline Hash& operator=(Hash&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Hash& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Hash* internal_default_instance() {
    return reinterpret_cast<const Hash*>(
               &_Hash_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Hash* other);
  friend void swap(Hash& a, Hash& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Hash* New() const PROTOBUF_FINAL { return New(NULL); }

  Hash* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Hash& from);
  void MergeFrom(const Hash& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Hash* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // fixed64 v0 = 1;
  void clear_v0();
  static const int kV0FieldNumber = 1;
  ::google::protobuf::uint64 v0() const;
  void set_v0(::google::protobuf::uint64 value);

  // fixed64 v1 = 2;
  void clear_v1();
  static const int kV1FieldNumber = 2;
  ::google::protobuf::uint64 v1() const;
  void set_v1(::google::protobuf::uint64 value);

  // fixed64 v2 = 3;
  void clear_v2();
  static const int kV2FieldNumber = 3;
  ::google::protobuf::uint64 v2() const;
  void set_v2(::google::protobuf::uint64 value);

  // fixed64 v3 = 4;
  void clear_v3();
  static const int kV3FieldNumber = 4;
  ::google::protobuf::uint64 v3() const;
  void set_v3(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.Hash)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 v0_;
  ::google::protobuf::uint64 v1_;
  ::google::protobuf::uint64 v2_;
  ::google::protobuf::uint64 v3_;
  mutable int _cached_size_;
  friend struct ::protobuf_bc_2eproto::TableStruct;
  friend void ::protobuf_bc_2eproto::InitDefaultsHashImpl();
};
// -------------------------------------------------------------------

class Program : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.Program) */ {
 public:
  Program();
  virtual ~Program();

  Program(const Program& from);

  inline Program& operator=(const Program& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Program(Program&& from) noexcept
    : Program() {
    *this = ::std::move(from);
  }

  inline Program& operator=(Program&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Program& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Program* internal_default_instance() {
    return reinterpret_cast<const Program*>(
               &_Program_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Program* other);
  friend void swap(Program& a, Program& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Program* New() const PROTOBUF_FINAL { return New(NULL); }

  Program* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Program& from);
  void MergeFrom(const Program& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Program* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes code = 2;
  void clear_code();
  static const int kCodeFieldNumber = 2;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  #if LANG_CXX11
  void set_code(::std::string&& value);
  #endif
  void set_code(const char* value);
  void set_code(const void* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // uint64 vm_version = 1;
  void clear_vm_version();
  static const int kVmVersionFieldNumber = 1;
  ::google::protobuf::uint64 vm_version() const;
  void set_vm_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.Program)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  ::google::protobuf::uint64 vm_version_;
  mutable int _cached_size_;
  friend struct ::protobuf_bc_2eproto::TableStruct;
  friend void ::protobuf_bc_2eproto::InitDefaultsProgramImpl();
};
// -------------------------------------------------------------------

class AssetID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.AssetID) */ {
 public:
  AssetID();
  virtual ~AssetID();

  AssetID(const AssetID& from);

  inline AssetID& operator=(const AssetID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AssetID(AssetID&& from) noexcept
    : AssetID() {
    *this = ::std::move(from);
  }

  inline AssetID& operator=(AssetID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssetID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AssetID* internal_default_instance() {
    return reinterpret_cast<const AssetID*>(
               &_AssetID_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(AssetID* other);
  friend void swap(AssetID& a, AssetID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AssetID* New() const PROTOBUF_FINAL { return New(NULL); }

  AssetID* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AssetID& from);
  void MergeFrom(const AssetID& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AssetID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // fixed64 v0 = 1;
  void clear_v0();
  static const int kV0FieldNumber = 1;
  ::google::protobuf::uint64 v0() const;
  void set_v0(::google::protobuf::uint64 value);

  // fixed64 v1 = 2;
  void clear_v1();
  static const int kV1FieldNumber = 2;
  ::google::protobuf::uint64 v1() const;
  void set_v1(::google::protobuf::uint64 value);

  // fixed64 v2 = 3;
  void clear_v2();
  static const int kV2FieldNumber = 3;
  ::google::protobuf::uint64 v2() const;
  void set_v2(::google::protobuf::uint64 value);

  // fixed64 v3 = 4;
  void clear_v3();
  static const int kV3FieldNumber = 4;
  ::google::protobuf::uint64 v3() const;
  void set_v3(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.AssetID)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 v0_;
  ::google::protobuf::uint64 v1_;
  ::google::protobuf::uint64 v2_;
  ::google::protobuf::uint64 v3_;
  mutable int _cached_size_;
  friend struct ::protobuf_bc_2eproto::TableStruct;
  friend void ::protobuf_bc_2eproto::InitDefaultsAssetIDImpl();
};
// -------------------------------------------------------------------

class AssetAmount : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.AssetAmount) */ {
 public:
  AssetAmount();
  virtual ~AssetAmount();

  AssetAmount(const AssetAmount& from);

  inline AssetAmount& operator=(const AssetAmount& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AssetAmount(AssetAmount&& from) noexcept
    : AssetAmount() {
    *this = ::std::move(from);
  }

  inline AssetAmount& operator=(AssetAmount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssetAmount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AssetAmount* internal_default_instance() {
    return reinterpret_cast<const AssetAmount*>(
               &_AssetAmount_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(AssetAmount* other);
  friend void swap(AssetAmount& a, AssetAmount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AssetAmount* New() const PROTOBUF_FINAL { return New(NULL); }

  AssetAmount* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AssetAmount& from);
  void MergeFrom(const AssetAmount& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AssetAmount* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .bc.AssetID asset_id = 1;
  bool has_asset_id() const;
  void clear_asset_id();
  static const int kAssetIdFieldNumber = 1;
  const ::bc::AssetID& asset_id() const;
  ::bc::AssetID* release_asset_id();
  ::bc::AssetID* mutable_asset_id();
  void set_allocated_asset_id(::bc::AssetID* asset_id);

  // uint64 amount = 2;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.AssetAmount)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::bc::AssetID* asset_id_;
  ::google::protobuf::uint64 amount_;
  mutable int _cached_size_;
  friend struct ::protobuf_bc_2eproto::TableStruct;
  friend void ::protobuf_bc_2eproto::InitDefaultsAssetAmountImpl();
};
// -------------------------------------------------------------------

class AssetDefinition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.AssetDefinition) */ {
 public:
  AssetDefinition();
  virtual ~AssetDefinition();

  AssetDefinition(const AssetDefinition& from);

  inline AssetDefinition& operator=(const AssetDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AssetDefinition(AssetDefinition&& from) noexcept
    : AssetDefinition() {
    *this = ::std::move(from);
  }

  inline AssetDefinition& operator=(AssetDefinition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssetDefinition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AssetDefinition* internal_default_instance() {
    return reinterpret_cast<const AssetDefinition*>(
               &_AssetDefinition_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(AssetDefinition* other);
  friend void swap(AssetDefinition& a, AssetDefinition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AssetDefinition* New() const PROTOBUF_FINAL { return New(NULL); }

  AssetDefinition* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AssetDefinition& from);
  void MergeFrom(const AssetDefinition& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AssetDefinition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .bc.Program issuance_program = 1;
  bool has_issuance_program() const;
  void clear_issuance_program();
  static const int kIssuanceProgramFieldNumber = 1;
  const ::bc::Program& issuance_program() const;
  ::bc::Program* release_issuance_program();
  ::bc::Program* mutable_issuance_program();
  void set_allocated_issuance_program(::bc::Program* issuance_program);

  // .bc.Hash data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::bc::Hash& data() const;
  ::bc::Hash* release_data();
  ::bc::Hash* mutable_data();
  void set_allocated_data(::bc::Hash* data);

  // @@protoc_insertion_point(class_scope:bc.AssetDefinition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::bc::Program* issuance_program_;
  ::bc::Hash* data_;
  mutable int _cached_size_;
  friend struct ::protobuf_bc_2eproto::TableStruct;
  friend void ::protobuf_bc_2eproto::InitDefaultsAssetDefinitionImpl();
};
// -------------------------------------------------------------------

class ValueSource : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.ValueSource) */ {
 public:
  ValueSource();
  virtual ~ValueSource();

  ValueSource(const ValueSource& from);

  inline ValueSource& operator=(const ValueSource& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ValueSource(ValueSource&& from) noexcept
    : ValueSource() {
    *this = ::std::move(from);
  }

  inline ValueSource& operator=(ValueSource&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ValueSource& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValueSource* internal_default_instance() {
    return reinterpret_cast<const ValueSource*>(
               &_ValueSource_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ValueSource* other);
  friend void swap(ValueSource& a, ValueSource& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ValueSource* New() const PROTOBUF_FINAL { return New(NULL); }

  ValueSource* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ValueSource& from);
  void MergeFrom(const ValueSource& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ValueSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .bc.Hash ref = 1;
  bool has_ref() const;
  void clear_ref();
  static const int kRefFieldNumber = 1;
  const ::bc::Hash& ref() const;
  ::bc::Hash* release_ref();
  ::bc::Hash* mutable_ref();
  void set_allocated_ref(::bc::Hash* ref);

  // .bc.AssetAmount value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::bc::AssetAmount& value() const;
  ::bc::AssetAmount* release_value();
  ::bc::AssetAmount* mutable_value();
  void set_allocated_value(::bc::AssetAmount* value);

  // uint64 position = 3;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  ::google::protobuf::uint64 position() const;
  void set_position(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.ValueSource)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::bc::Hash* ref_;
  ::bc::AssetAmount* value_;
  ::google::protobuf::uint64 position_;
  mutable int _cached_size_;
  friend struct ::protobuf_bc_2eproto::TableStruct;
  friend void ::protobuf_bc_2eproto::InitDefaultsValueSourceImpl();
};
// -------------------------------------------------------------------

class ValueDestination : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.ValueDestination) */ {
 public:
  ValueDestination();
  virtual ~ValueDestination();

  ValueDestination(const ValueDestination& from);

  inline ValueDestination& operator=(const ValueDestination& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ValueDestination(ValueDestination&& from) noexcept
    : ValueDestination() {
    *this = ::std::move(from);
  }

  inline ValueDestination& operator=(ValueDestination&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ValueDestination& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValueDestination* internal_default_instance() {
    return reinterpret_cast<const ValueDestination*>(
               &_ValueDestination_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ValueDestination* other);
  friend void swap(ValueDestination& a, ValueDestination& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ValueDestination* New() const PROTOBUF_FINAL { return New(NULL); }

  ValueDestination* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ValueDestination& from);
  void MergeFrom(const ValueDestination& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ValueDestination* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .bc.Hash ref = 1;
  bool has_ref() const;
  void clear_ref();
  static const int kRefFieldNumber = 1;
  const ::bc::Hash& ref() const;
  ::bc::Hash* release_ref();
  ::bc::Hash* mutable_ref();
  void set_allocated_ref(::bc::Hash* ref);

  // .bc.AssetAmount value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::bc::AssetAmount& value() const;
  ::bc::AssetAmount* release_value();
  ::bc::AssetAmount* mutable_value();
  void set_allocated_value(::bc::AssetAmount* value);

  // uint64 position = 3;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  ::google::protobuf::uint64 position() const;
  void set_position(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.ValueDestination)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::bc::Hash* ref_;
  ::bc::AssetAmount* value_;
  ::google::protobuf::uint64 position_;
  mutable int _cached_size_;
  friend struct ::protobuf_bc_2eproto::TableStruct;
  friend void ::protobuf_bc_2eproto::InitDefaultsValueDestinationImpl();
};
// -------------------------------------------------------------------

class BlockHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.BlockHeader) */ {
 public:
  BlockHeader();
  virtual ~BlockHeader();

  BlockHeader(const BlockHeader& from);

  inline BlockHeader& operator=(const BlockHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockHeader(BlockHeader&& from) noexcept
    : BlockHeader() {
    *this = ::std::move(from);
  }

  inline BlockHeader& operator=(BlockHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockHeader* internal_default_instance() {
    return reinterpret_cast<const BlockHeader*>(
               &_BlockHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(BlockHeader* other);
  friend void swap(BlockHeader& a, BlockHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  BlockHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlockHeader& from);
  void MergeFrom(const BlockHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlockHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .bc.Hash previous_block_id = 3;
  bool has_previous_block_id() const;
  void clear_previous_block_id();
  static const int kPreviousBlockIdFieldNumber = 3;
  const ::bc::Hash& previous_block_id() const;
  ::bc::Hash* release_previous_block_id();
  ::bc::Hash* mutable_previous_block_id();
  void set_allocated_previous_block_id(::bc::Hash* previous_block_id);

  // .bc.Hash transactions_root = 5;
  bool has_transactions_root() const;
  void clear_transactions_root();
  static const int kTransactionsRootFieldNumber = 5;
  const ::bc::Hash& transactions_root() const;
  ::bc::Hash* release_transactions_root();
  ::bc::Hash* mutable_transactions_root();
  void set_allocated_transactions_root(::bc::Hash* transactions_root);

  // .bc.Hash transaction_status_hash = 6;
  bool has_transaction_status_hash() const;
  void clear_transaction_status_hash();
  static const int kTransactionStatusHashFieldNumber = 6;
  const ::bc::Hash& transaction_status_hash() const;
  ::bc::Hash* release_transaction_status_hash();
  ::bc::Hash* mutable_transaction_status_hash();
  void set_allocated_transaction_status_hash(::bc::Hash* transaction_status_hash);

  // .bc.TransactionStatus transaction_status = 9;
  bool has_transaction_status() const;
  void clear_transaction_status();
  static const int kTransactionStatusFieldNumber = 9;
  const ::bc::TransactionStatus& transaction_status() const;
  ::bc::TransactionStatus* release_transaction_status();
  ::bc::TransactionStatus* mutable_transaction_status();
  void set_allocated_transaction_status(::bc::TransactionStatus* transaction_status);

  // uint64 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint64 version() const;
  void set_version(::google::protobuf::uint64 value);

  // uint64 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::uint64 height() const;
  void set_height(::google::protobuf::uint64 value);

  // uint64 timestamp = 4;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // uint64 nonce = 7;
  void clear_nonce();
  static const int kNonceFieldNumber = 7;
  ::google::protobuf::uint64 nonce() const;
  void set_nonce(::google::protobuf::uint64 value);

  // uint64 bits = 8;
  void clear_bits();
  static const int kBitsFieldNumber = 8;
  ::google::protobuf::uint64 bits() const;
  void set_bits(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.BlockHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::bc::Hash* previous_block_id_;
  ::bc::Hash* transactions_root_;
  ::bc::Hash* transaction_status_hash_;
  ::bc::TransactionStatus* transaction_status_;
  ::google::protobuf::uint64 version_;
  ::google::protobuf::uint64 height_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint64 nonce_;
  ::google::protobuf::uint64 bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_bc_2eproto::TableStruct;
  friend void ::protobuf_bc_2eproto::InitDefaultsBlockHeaderImpl();
};
// -------------------------------------------------------------------

class TxHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.TxHeader) */ {
 public:
  TxHeader();
  virtual ~TxHeader();

  TxHeader(const TxHeader& from);

  inline TxHeader& operator=(const TxHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxHeader(TxHeader&& from) noexcept
    : TxHeader() {
    *this = ::std::move(from);
  }

  inline TxHeader& operator=(TxHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TxHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxHeader* internal_default_instance() {
    return reinterpret_cast<const TxHeader*>(
               &_TxHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(TxHeader* other);
  friend void swap(TxHeader& a, TxHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  TxHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TxHeader& from);
  void MergeFrom(const TxHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TxHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bc.Hash result_ids = 4;
  int result_ids_size() const;
  void clear_result_ids();
  static const int kResultIdsFieldNumber = 4;
  const ::bc::Hash& result_ids(int index) const;
  ::bc::Hash* mutable_result_ids(int index);
  ::bc::Hash* add_result_ids();
  ::google::protobuf::RepeatedPtrField< ::bc::Hash >*
      mutable_result_ids();
  const ::google::protobuf::RepeatedPtrField< ::bc::Hash >&
      result_ids() const;

  // uint64 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint64 version() const;
  void set_version(::google::protobuf::uint64 value);

  // uint64 serialized_size = 2;
  void clear_serialized_size();
  static const int kSerializedSizeFieldNumber = 2;
  ::google::protobuf::uint64 serialized_size() const;
  void set_serialized_size(::google::protobuf::uint64 value);

  // uint64 time_range = 3;
  void clear_time_range();
  static const int kTimeRangeFieldNumber = 3;
  ::google::protobuf::uint64 time_range() const;
  void set_time_range(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.TxHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::bc::Hash > result_ids_;
  ::google::protobuf::uint64 version_;
  ::google::protobuf::uint64 serialized_size_;
  ::google::protobuf::uint64 time_range_;
  mutable int _cached_size_;
  friend struct ::protobuf_bc_2eproto::TableStruct;
  friend void ::protobuf_bc_2eproto::InitDefaultsTxHeaderImpl();
};
// -------------------------------------------------------------------

class TxVerifyResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.TxVerifyResult) */ {
 public:
  TxVerifyResult();
  virtual ~TxVerifyResult();

  TxVerifyResult(const TxVerifyResult& from);

  inline TxVerifyResult& operator=(const TxVerifyResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxVerifyResult(TxVerifyResult&& from) noexcept
    : TxVerifyResult() {
    *this = ::std::move(from);
  }

  inline TxVerifyResult& operator=(TxVerifyResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TxVerifyResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxVerifyResult* internal_default_instance() {
    return reinterpret_cast<const TxVerifyResult*>(
               &_TxVerifyResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(TxVerifyResult* other);
  friend void swap(TxVerifyResult& a, TxVerifyResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxVerifyResult* New() const PROTOBUF_FINAL { return New(NULL); }

  TxVerifyResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TxVerifyResult& from);
  void MergeFrom(const TxVerifyResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TxVerifyResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool status_fail = 1;
  void clear_status_fail();
  static const int kStatusFailFieldNumber = 1;
  bool status_fail() const;
  void set_status_fail(bool value);

  // @@protoc_insertion_point(class_scope:bc.TxVerifyResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool status_fail_;
  mutable int _cached_size_;
  friend struct ::protobuf_bc_2eproto::TableStruct;
  friend void ::protobuf_bc_2eproto::InitDefaultsTxVerifyResultImpl();
};
// -------------------------------------------------------------------

class TransactionStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.TransactionStatus) */ {
 public:
  TransactionStatus();
  virtual ~TransactionStatus();

  TransactionStatus(const TransactionStatus& from);

  inline TransactionStatus& operator=(const TransactionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransactionStatus(TransactionStatus&& from) noexcept
    : TransactionStatus() {
    *this = ::std::move(from);
  }

  inline TransactionStatus& operator=(TransactionStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransactionStatus* internal_default_instance() {
    return reinterpret_cast<const TransactionStatus*>(
               &_TransactionStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(TransactionStatus* other);
  friend void swap(TransactionStatus& a, TransactionStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransactionStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  TransactionStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TransactionStatus& from);
  void MergeFrom(const TransactionStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TransactionStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bc.TxVerifyResult verify_status = 2;
  int verify_status_size() const;
  void clear_verify_status();
  static const int kVerifyStatusFieldNumber = 2;
  const ::bc::TxVerifyResult& verify_status(int index) const;
  ::bc::TxVerifyResult* mutable_verify_status(int index);
  ::bc::TxVerifyResult* add_verify_status();
  ::google::protobuf::RepeatedPtrField< ::bc::TxVerifyResult >*
      mutable_verify_status();
  const ::google::protobuf::RepeatedPtrField< ::bc::TxVerifyResult >&
      verify_status() const;

  // uint64 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint64 version() const;
  void set_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.TransactionStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::bc::TxVerifyResult > verify_status_;
  ::google::protobuf::uint64 version_;
  mutable int _cached_size_;
  friend struct ::protobuf_bc_2eproto::TableStruct;
  friend void ::protobuf_bc_2eproto::InitDefaultsTransactionStatusImpl();
};
// -------------------------------------------------------------------

class Mux : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.Mux) */ {
 public:
  Mux();
  virtual ~Mux();

  Mux(const Mux& from);

  inline Mux& operator=(const Mux& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Mux(Mux&& from) noexcept
    : Mux() {
    *this = ::std::move(from);
  }

  inline Mux& operator=(Mux&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Mux& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Mux* internal_default_instance() {
    return reinterpret_cast<const Mux*>(
               &_Mux_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Mux* other);
  friend void swap(Mux& a, Mux& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Mux* New() const PROTOBUF_FINAL { return New(NULL); }

  Mux* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Mux& from);
  void MergeFrom(const Mux& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Mux* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bc.ValueSource sources = 1;
  int sources_size() const;
  void clear_sources();
  static const int kSourcesFieldNumber = 1;
  const ::bc::ValueSource& sources(int index) const;
  ::bc::ValueSource* mutable_sources(int index);
  ::bc::ValueSource* add_sources();
  ::google::protobuf::RepeatedPtrField< ::bc::ValueSource >*
      mutable_sources();
  const ::google::protobuf::RepeatedPtrField< ::bc::ValueSource >&
      sources() const;

  // repeated .bc.ValueDestination witness_destinations = 3;
  int witness_destinations_size() const;
  void clear_witness_destinations();
  static const int kWitnessDestinationsFieldNumber = 3;
  const ::bc::ValueDestination& witness_destinations(int index) const;
  ::bc::ValueDestination* mutable_witness_destinations(int index);
  ::bc::ValueDestination* add_witness_destinations();
  ::google::protobuf::RepeatedPtrField< ::bc::ValueDestination >*
      mutable_witness_destinations();
  const ::google::protobuf::RepeatedPtrField< ::bc::ValueDestination >&
      witness_destinations() const;

  // repeated bytes witness_arguments = 4;
  int witness_arguments_size() const;
  void clear_witness_arguments();
  static const int kWitnessArgumentsFieldNumber = 4;
  const ::std::string& witness_arguments(int index) const;
  ::std::string* mutable_witness_arguments(int index);
  void set_witness_arguments(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_witness_arguments(int index, ::std::string&& value);
  #endif
  void set_witness_arguments(int index, const char* value);
  void set_witness_arguments(int index, const void* value, size_t size);
  ::std::string* add_witness_arguments();
  void add_witness_arguments(const ::std::string& value);
  #if LANG_CXX11
  void add_witness_arguments(::std::string&& value);
  #endif
  void add_witness_arguments(const char* value);
  void add_witness_arguments(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& witness_arguments() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_witness_arguments();

  // .bc.Program program = 2;
  bool has_program() const;
  void clear_program();
  static const int kProgramFieldNumber = 2;
  const ::bc::Program& program() const;
  ::bc::Program* release_program();
  ::bc::Program* mutable_program();
  void set_allocated_program(::bc::Program* program);

  // @@protoc_insertion_point(class_scope:bc.Mux)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::bc::ValueSource > sources_;
  ::google::protobuf::RepeatedPtrField< ::bc::ValueDestination > witness_destinations_;
  ::google::protobuf::RepeatedPtrField< ::std::string> witness_arguments_;
  ::bc::Program* program_;
  mutable int _cached_size_;
  friend struct ::protobuf_bc_2eproto::TableStruct;
  friend void ::protobuf_bc_2eproto::InitDefaultsMuxImpl();
};
// -------------------------------------------------------------------

class Coinbase : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.Coinbase) */ {
 public:
  Coinbase();
  virtual ~Coinbase();

  Coinbase(const Coinbase& from);

  inline Coinbase& operator=(const Coinbase& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Coinbase(Coinbase&& from) noexcept
    : Coinbase() {
    *this = ::std::move(from);
  }

  inline Coinbase& operator=(Coinbase&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Coinbase& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Coinbase* internal_default_instance() {
    return reinterpret_cast<const Coinbase*>(
               &_Coinbase_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(Coinbase* other);
  friend void swap(Coinbase& a, Coinbase& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Coinbase* New() const PROTOBUF_FINAL { return New(NULL); }

  Coinbase* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Coinbase& from);
  void MergeFrom(const Coinbase& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Coinbase* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes arbitrary = 2;
  void clear_arbitrary();
  static const int kArbitraryFieldNumber = 2;
  const ::std::string& arbitrary() const;
  void set_arbitrary(const ::std::string& value);
  #if LANG_CXX11
  void set_arbitrary(::std::string&& value);
  #endif
  void set_arbitrary(const char* value);
  void set_arbitrary(const void* value, size_t size);
  ::std::string* mutable_arbitrary();
  ::std::string* release_arbitrary();
  void set_allocated_arbitrary(::std::string* arbitrary);

  // .bc.ValueDestination witness_destination = 1;
  bool has_witness_destination() const;
  void clear_witness_destination();
  static const int kWitnessDestinationFieldNumber = 1;
  const ::bc::ValueDestination& witness_destination() const;
  ::bc::ValueDestination* release_witness_destination();
  ::bc::ValueDestination* mutable_witness_destination();
  void set_allocated_witness_destination(::bc::ValueDestination* witness_destination);

  // @@protoc_insertion_point(class_scope:bc.Coinbase)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr arbitrary_;
  ::bc::ValueDestination* witness_destination_;
  mutable int _cached_size_;
  friend struct ::protobuf_bc_2eproto::TableStruct;
  friend void ::protobuf_bc_2eproto::InitDefaultsCoinbaseImpl();
};
// -------------------------------------------------------------------

class Output : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.Output) */ {
 public:
  Output();
  virtual ~Output();

  Output(const Output& from);

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Output(Output&& from) noexcept
    : Output() {
    *this = ::std::move(from);
  }

  inline Output& operator=(Output&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Output& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Output* internal_default_instance() {
    return reinterpret_cast<const Output*>(
               &_Output_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(Output* other);
  friend void swap(Output& a, Output& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Output* New() const PROTOBUF_FINAL { return New(NULL); }

  Output* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Output& from);
  void MergeFrom(const Output& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Output* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .bc.ValueSource source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::bc::ValueSource& source() const;
  ::bc::ValueSource* release_source();
  ::bc::ValueSource* mutable_source();
  void set_allocated_source(::bc::ValueSource* source);

  // .bc.Program control_program = 2;
  bool has_control_program() const;
  void clear_control_program();
  static const int kControlProgramFieldNumber = 2;
  const ::bc::Program& control_program() const;
  ::bc::Program* release_control_program();
  ::bc::Program* mutable_control_program();
  void set_allocated_control_program(::bc::Program* control_program);

  // uint64 ordinal = 3;
  void clear_ordinal();
  static const int kOrdinalFieldNumber = 3;
  ::google::protobuf::uint64 ordinal() const;
  void set_ordinal(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.Output)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::bc::ValueSource* source_;
  ::bc::Program* control_program_;
  ::google::protobuf::uint64 ordinal_;
  mutable int _cached_size_;
  friend struct ::protobuf_bc_2eproto::TableStruct;
  friend void ::protobuf_bc_2eproto::InitDefaultsOutputImpl();
};
// -------------------------------------------------------------------

class Retirement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.Retirement) */ {
 public:
  Retirement();
  virtual ~Retirement();

  Retirement(const Retirement& from);

  inline Retirement& operator=(const Retirement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Retirement(Retirement&& from) noexcept
    : Retirement() {
    *this = ::std::move(from);
  }

  inline Retirement& operator=(Retirement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Retirement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Retirement* internal_default_instance() {
    return reinterpret_cast<const Retirement*>(
               &_Retirement_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(Retirement* other);
  friend void swap(Retirement& a, Retirement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Retirement* New() const PROTOBUF_FINAL { return New(NULL); }

  Retirement* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Retirement& from);
  void MergeFrom(const Retirement& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Retirement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .bc.ValueSource source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::bc::ValueSource& source() const;
  ::bc::ValueSource* release_source();
  ::bc::ValueSource* mutable_source();
  void set_allocated_source(::bc::ValueSource* source);

  // uint64 ordinal = 2;
  void clear_ordinal();
  static const int kOrdinalFieldNumber = 2;
  ::google::protobuf::uint64 ordinal() const;
  void set_ordinal(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.Retirement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::bc::ValueSource* source_;
  ::google::protobuf::uint64 ordinal_;
  mutable int _cached_size_;
  friend struct ::protobuf_bc_2eproto::TableStruct;
  friend void ::protobuf_bc_2eproto::InitDefaultsRetirementImpl();
};
// -------------------------------------------------------------------

class Issuance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.Issuance) */ {
 public:
  Issuance();
  virtual ~Issuance();

  Issuance(const Issuance& from);

  inline Issuance& operator=(const Issuance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Issuance(Issuance&& from) noexcept
    : Issuance() {
    *this = ::std::move(from);
  }

  inline Issuance& operator=(Issuance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Issuance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Issuance* internal_default_instance() {
    return reinterpret_cast<const Issuance*>(
               &_Issuance_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(Issuance* other);
  friend void swap(Issuance& a, Issuance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Issuance* New() const PROTOBUF_FINAL { return New(NULL); }

  Issuance* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Issuance& from);
  void MergeFrom(const Issuance& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Issuance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes witness_arguments = 5;
  int witness_arguments_size() const;
  void clear_witness_arguments();
  static const int kWitnessArgumentsFieldNumber = 5;
  const ::std::string& witness_arguments(int index) const;
  ::std::string* mutable_witness_arguments(int index);
  void set_witness_arguments(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_witness_arguments(int index, ::std::string&& value);
  #endif
  void set_witness_arguments(int index, const char* value);
  void set_witness_arguments(int index, const void* value, size_t size);
  ::std::string* add_witness_arguments();
  void add_witness_arguments(const ::std::string& value);
  #if LANG_CXX11
  void add_witness_arguments(::std::string&& value);
  #endif
  void add_witness_arguments(const char* value);
  void add_witness_arguments(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& witness_arguments() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_witness_arguments();

  // .bc.Hash nonce_hash = 1;
  bool has_nonce_hash() const;
  void clear_nonce_hash();
  static const int kNonceHashFieldNumber = 1;
  const ::bc::Hash& nonce_hash() const;
  ::bc::Hash* release_nonce_hash();
  ::bc::Hash* mutable_nonce_hash();
  void set_allocated_nonce_hash(::bc::Hash* nonce_hash);

  // .bc.AssetAmount value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::bc::AssetAmount& value() const;
  ::bc::AssetAmount* release_value();
  ::bc::AssetAmount* mutable_value();
  void set_allocated_value(::bc::AssetAmount* value);

  // .bc.ValueDestination witness_destination = 3;
  bool has_witness_destination() const;
  void clear_witness_destination();
  static const int kWitnessDestinationFieldNumber = 3;
  const ::bc::ValueDestination& witness_destination() const;
  ::bc::ValueDestination* release_witness_destination();
  ::bc::ValueDestination* mutable_witness_destination();
  void set_allocated_witness_destination(::bc::ValueDestination* witness_destination);

  // .bc.AssetDefinition witness_asset_definition = 4;
  bool has_witness_asset_definition() const;
  void clear_witness_asset_definition();
  static const int kWitnessAssetDefinitionFieldNumber = 4;
  const ::bc::AssetDefinition& witness_asset_definition() const;
  ::bc::AssetDefinition* release_witness_asset_definition();
  ::bc::AssetDefinition* mutable_witness_asset_definition();
  void set_allocated_witness_asset_definition(::bc::AssetDefinition* witness_asset_definition);

  // uint64 ordinal = 6;
  void clear_ordinal();
  static const int kOrdinalFieldNumber = 6;
  ::google::protobuf::uint64 ordinal() const;
  void set_ordinal(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.Issuance)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> witness_arguments_;
  ::bc::Hash* nonce_hash_;
  ::bc::AssetAmount* value_;
  ::bc::ValueDestination* witness_destination_;
  ::bc::AssetDefinition* witness_asset_definition_;
  ::google::protobuf::uint64 ordinal_;
  mutable int _cached_size_;
  friend struct ::protobuf_bc_2eproto::TableStruct;
  friend void ::protobuf_bc_2eproto::InitDefaultsIssuanceImpl();
};
// -------------------------------------------------------------------

class Spend : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bc.Spend) */ {
 public:
  Spend();
  virtual ~Spend();

  Spend(const Spend& from);

  inline Spend& operator=(const Spend& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Spend(Spend&& from) noexcept
    : Spend() {
    *this = ::std::move(from);
  }

  inline Spend& operator=(Spend&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Spend& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Spend* internal_default_instance() {
    return reinterpret_cast<const Spend*>(
               &_Spend_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(Spend* other);
  friend void swap(Spend& a, Spend& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Spend* New() const PROTOBUF_FINAL { return New(NULL); }

  Spend* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Spend& from);
  void MergeFrom(const Spend& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Spend* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes witness_arguments = 3;
  int witness_arguments_size() const;
  void clear_witness_arguments();
  static const int kWitnessArgumentsFieldNumber = 3;
  const ::std::string& witness_arguments(int index) const;
  ::std::string* mutable_witness_arguments(int index);
  void set_witness_arguments(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_witness_arguments(int index, ::std::string&& value);
  #endif
  void set_witness_arguments(int index, const char* value);
  void set_witness_arguments(int index, const void* value, size_t size);
  ::std::string* add_witness_arguments();
  void add_witness_arguments(const ::std::string& value);
  #if LANG_CXX11
  void add_witness_arguments(::std::string&& value);
  #endif
  void add_witness_arguments(const char* value);
  void add_witness_arguments(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& witness_arguments() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_witness_arguments();

  // .bc.Hash spent_output_id = 1;
  bool has_spent_output_id() const;
  void clear_spent_output_id();
  static const int kSpentOutputIdFieldNumber = 1;
  const ::bc::Hash& spent_output_id() const;
  ::bc::Hash* release_spent_output_id();
  ::bc::Hash* mutable_spent_output_id();
  void set_allocated_spent_output_id(::bc::Hash* spent_output_id);

  // .bc.ValueDestination witness_destination = 2;
  bool has_witness_destination() const;
  void clear_witness_destination();
  static const int kWitnessDestinationFieldNumber = 2;
  const ::bc::ValueDestination& witness_destination() const;
  ::bc::ValueDestination* release_witness_destination();
  ::bc::ValueDestination* mutable_witness_destination();
  void set_allocated_witness_destination(::bc::ValueDestination* witness_destination);

  // uint64 ordinal = 4;
  void clear_ordinal();
  static const int kOrdinalFieldNumber = 4;
  ::google::protobuf::uint64 ordinal() const;
  void set_ordinal(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bc.Spend)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> witness_arguments_;
  ::bc::Hash* spent_output_id_;
  ::bc::ValueDestination* witness_destination_;
  ::google::protobuf::uint64 ordinal_;
  mutable int _cached_size_;
  friend struct ::protobuf_bc_2eproto::TableStruct;
  friend void ::protobuf_bc_2eproto::InitDefaultsSpendImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Hash

// fixed64 v0 = 1;
inline void Hash::clear_v0() {
  v0_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Hash::v0() const {
  // @@protoc_insertion_point(field_get:bc.Hash.v0)
  return v0_;
}
inline void Hash::set_v0(::google::protobuf::uint64 value) {
  
  v0_ = value;
  // @@protoc_insertion_point(field_set:bc.Hash.v0)
}

// fixed64 v1 = 2;
inline void Hash::clear_v1() {
  v1_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Hash::v1() const {
  // @@protoc_insertion_point(field_get:bc.Hash.v1)
  return v1_;
}
inline void Hash::set_v1(::google::protobuf::uint64 value) {
  
  v1_ = value;
  // @@protoc_insertion_point(field_set:bc.Hash.v1)
}

// fixed64 v2 = 3;
inline void Hash::clear_v2() {
  v2_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Hash::v2() const {
  // @@protoc_insertion_point(field_get:bc.Hash.v2)
  return v2_;
}
inline void Hash::set_v2(::google::protobuf::uint64 value) {
  
  v2_ = value;
  // @@protoc_insertion_point(field_set:bc.Hash.v2)
}

// fixed64 v3 = 4;
inline void Hash::clear_v3() {
  v3_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Hash::v3() const {
  // @@protoc_insertion_point(field_get:bc.Hash.v3)
  return v3_;
}
inline void Hash::set_v3(::google::protobuf::uint64 value) {
  
  v3_ = value;
  // @@protoc_insertion_point(field_set:bc.Hash.v3)
}

// -------------------------------------------------------------------

// Program

// uint64 vm_version = 1;
inline void Program::clear_vm_version() {
  vm_version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Program::vm_version() const {
  // @@protoc_insertion_point(field_get:bc.Program.vm_version)
  return vm_version_;
}
inline void Program::set_vm_version(::google::protobuf::uint64 value) {
  
  vm_version_ = value;
  // @@protoc_insertion_point(field_set:bc.Program.vm_version)
}

// bytes code = 2;
inline void Program::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Program::code() const {
  // @@protoc_insertion_point(field_get:bc.Program.code)
  return code_.GetNoArena();
}
inline void Program::set_code(const ::std::string& value) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bc.Program.code)
}
#if LANG_CXX11
inline void Program::set_code(::std::string&& value) {
  
  code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bc.Program.code)
}
#endif
inline void Program::set_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bc.Program.code)
}
inline void Program::set_code(const void* value, size_t size) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bc.Program.code)
}
inline ::std::string* Program::mutable_code() {
  
  // @@protoc_insertion_point(field_mutable:bc.Program.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Program::release_code() {
  // @@protoc_insertion_point(field_release:bc.Program.code)
  
  return code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Program::set_allocated_code(::std::string* code) {
  if (code != NULL) {
    
  } else {
    
  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:bc.Program.code)
}

// -------------------------------------------------------------------

// AssetID

// fixed64 v0 = 1;
inline void AssetID::clear_v0() {
  v0_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AssetID::v0() const {
  // @@protoc_insertion_point(field_get:bc.AssetID.v0)
  return v0_;
}
inline void AssetID::set_v0(::google::protobuf::uint64 value) {
  
  v0_ = value;
  // @@protoc_insertion_point(field_set:bc.AssetID.v0)
}

// fixed64 v1 = 2;
inline void AssetID::clear_v1() {
  v1_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AssetID::v1() const {
  // @@protoc_insertion_point(field_get:bc.AssetID.v1)
  return v1_;
}
inline void AssetID::set_v1(::google::protobuf::uint64 value) {
  
  v1_ = value;
  // @@protoc_insertion_point(field_set:bc.AssetID.v1)
}

// fixed64 v2 = 3;
inline void AssetID::clear_v2() {
  v2_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AssetID::v2() const {
  // @@protoc_insertion_point(field_get:bc.AssetID.v2)
  return v2_;
}
inline void AssetID::set_v2(::google::protobuf::uint64 value) {
  
  v2_ = value;
  // @@protoc_insertion_point(field_set:bc.AssetID.v2)
}

// fixed64 v3 = 4;
inline void AssetID::clear_v3() {
  v3_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AssetID::v3() const {
  // @@protoc_insertion_point(field_get:bc.AssetID.v3)
  return v3_;
}
inline void AssetID::set_v3(::google::protobuf::uint64 value) {
  
  v3_ = value;
  // @@protoc_insertion_point(field_set:bc.AssetID.v3)
}

// -------------------------------------------------------------------

// AssetAmount

// .bc.AssetID asset_id = 1;
inline bool AssetAmount::has_asset_id() const {
  return this != internal_default_instance() && asset_id_ != NULL;
}
inline void AssetAmount::clear_asset_id() {
  if (GetArenaNoVirtual() == NULL && asset_id_ != NULL) {
    delete asset_id_;
  }
  asset_id_ = NULL;
}
inline const ::bc::AssetID& AssetAmount::asset_id() const {
  const ::bc::AssetID* p = asset_id_;
  // @@protoc_insertion_point(field_get:bc.AssetAmount.asset_id)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::AssetID*>(
      &::bc::_AssetID_default_instance_);
}
inline ::bc::AssetID* AssetAmount::release_asset_id() {
  // @@protoc_insertion_point(field_release:bc.AssetAmount.asset_id)
  
  ::bc::AssetID* temp = asset_id_;
  asset_id_ = NULL;
  return temp;
}
inline ::bc::AssetID* AssetAmount::mutable_asset_id() {
  
  if (asset_id_ == NULL) {
    asset_id_ = new ::bc::AssetID;
  }
  // @@protoc_insertion_point(field_mutable:bc.AssetAmount.asset_id)
  return asset_id_;
}
inline void AssetAmount::set_allocated_asset_id(::bc::AssetID* asset_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete asset_id_;
  }
  if (asset_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      asset_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, asset_id, submessage_arena);
    }
    
  } else {
    
  }
  asset_id_ = asset_id;
  // @@protoc_insertion_point(field_set_allocated:bc.AssetAmount.asset_id)
}

// uint64 amount = 2;
inline void AssetAmount::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AssetAmount::amount() const {
  // @@protoc_insertion_point(field_get:bc.AssetAmount.amount)
  return amount_;
}
inline void AssetAmount::set_amount(::google::protobuf::uint64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:bc.AssetAmount.amount)
}

// -------------------------------------------------------------------

// AssetDefinition

// .bc.Program issuance_program = 1;
inline bool AssetDefinition::has_issuance_program() const {
  return this != internal_default_instance() && issuance_program_ != NULL;
}
inline void AssetDefinition::clear_issuance_program() {
  if (GetArenaNoVirtual() == NULL && issuance_program_ != NULL) {
    delete issuance_program_;
  }
  issuance_program_ = NULL;
}
inline const ::bc::Program& AssetDefinition::issuance_program() const {
  const ::bc::Program* p = issuance_program_;
  // @@protoc_insertion_point(field_get:bc.AssetDefinition.issuance_program)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::Program*>(
      &::bc::_Program_default_instance_);
}
inline ::bc::Program* AssetDefinition::release_issuance_program() {
  // @@protoc_insertion_point(field_release:bc.AssetDefinition.issuance_program)
  
  ::bc::Program* temp = issuance_program_;
  issuance_program_ = NULL;
  return temp;
}
inline ::bc::Program* AssetDefinition::mutable_issuance_program() {
  
  if (issuance_program_ == NULL) {
    issuance_program_ = new ::bc::Program;
  }
  // @@protoc_insertion_point(field_mutable:bc.AssetDefinition.issuance_program)
  return issuance_program_;
}
inline void AssetDefinition::set_allocated_issuance_program(::bc::Program* issuance_program) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete issuance_program_;
  }
  if (issuance_program) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      issuance_program = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, issuance_program, submessage_arena);
    }
    
  } else {
    
  }
  issuance_program_ = issuance_program;
  // @@protoc_insertion_point(field_set_allocated:bc.AssetDefinition.issuance_program)
}

// .bc.Hash data = 2;
inline bool AssetDefinition::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline void AssetDefinition::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) {
    delete data_;
  }
  data_ = NULL;
}
inline const ::bc::Hash& AssetDefinition::data() const {
  const ::bc::Hash* p = data_;
  // @@protoc_insertion_point(field_get:bc.AssetDefinition.data)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::Hash*>(
      &::bc::_Hash_default_instance_);
}
inline ::bc::Hash* AssetDefinition::release_data() {
  // @@protoc_insertion_point(field_release:bc.AssetDefinition.data)
  
  ::bc::Hash* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::bc::Hash* AssetDefinition::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.AssetDefinition.data)
  return data_;
}
inline void AssetDefinition::set_allocated_data(::bc::Hash* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete data_;
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:bc.AssetDefinition.data)
}

// -------------------------------------------------------------------

// ValueSource

// .bc.Hash ref = 1;
inline bool ValueSource::has_ref() const {
  return this != internal_default_instance() && ref_ != NULL;
}
inline void ValueSource::clear_ref() {
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) {
    delete ref_;
  }
  ref_ = NULL;
}
inline const ::bc::Hash& ValueSource::ref() const {
  const ::bc::Hash* p = ref_;
  // @@protoc_insertion_point(field_get:bc.ValueSource.ref)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::Hash*>(
      &::bc::_Hash_default_instance_);
}
inline ::bc::Hash* ValueSource::release_ref() {
  // @@protoc_insertion_point(field_release:bc.ValueSource.ref)
  
  ::bc::Hash* temp = ref_;
  ref_ = NULL;
  return temp;
}
inline ::bc::Hash* ValueSource::mutable_ref() {
  
  if (ref_ == NULL) {
    ref_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.ValueSource.ref)
  return ref_;
}
inline void ValueSource::set_allocated_ref(::bc::Hash* ref) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ref_;
  }
  if (ref) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ref = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ref, submessage_arena);
    }
    
  } else {
    
  }
  ref_ = ref;
  // @@protoc_insertion_point(field_set_allocated:bc.ValueSource.ref)
}

// .bc.AssetAmount value = 2;
inline bool ValueSource::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void ValueSource::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) {
    delete value_;
  }
  value_ = NULL;
}
inline const ::bc::AssetAmount& ValueSource::value() const {
  const ::bc::AssetAmount* p = value_;
  // @@protoc_insertion_point(field_get:bc.ValueSource.value)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::AssetAmount*>(
      &::bc::_AssetAmount_default_instance_);
}
inline ::bc::AssetAmount* ValueSource::release_value() {
  // @@protoc_insertion_point(field_release:bc.ValueSource.value)
  
  ::bc::AssetAmount* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::bc::AssetAmount* ValueSource::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::bc::AssetAmount;
  }
  // @@protoc_insertion_point(field_mutable:bc.ValueSource.value)
  return value_;
}
inline void ValueSource::set_allocated_value(::bc::AssetAmount* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:bc.ValueSource.value)
}

// uint64 position = 3;
inline void ValueSource::clear_position() {
  position_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ValueSource::position() const {
  // @@protoc_insertion_point(field_get:bc.ValueSource.position)
  return position_;
}
inline void ValueSource::set_position(::google::protobuf::uint64 value) {
  
  position_ = value;
  // @@protoc_insertion_point(field_set:bc.ValueSource.position)
}

// -------------------------------------------------------------------

// ValueDestination

// .bc.Hash ref = 1;
inline bool ValueDestination::has_ref() const {
  return this != internal_default_instance() && ref_ != NULL;
}
inline void ValueDestination::clear_ref() {
  if (GetArenaNoVirtual() == NULL && ref_ != NULL) {
    delete ref_;
  }
  ref_ = NULL;
}
inline const ::bc::Hash& ValueDestination::ref() const {
  const ::bc::Hash* p = ref_;
  // @@protoc_insertion_point(field_get:bc.ValueDestination.ref)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::Hash*>(
      &::bc::_Hash_default_instance_);
}
inline ::bc::Hash* ValueDestination::release_ref() {
  // @@protoc_insertion_point(field_release:bc.ValueDestination.ref)
  
  ::bc::Hash* temp = ref_;
  ref_ = NULL;
  return temp;
}
inline ::bc::Hash* ValueDestination::mutable_ref() {
  
  if (ref_ == NULL) {
    ref_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.ValueDestination.ref)
  return ref_;
}
inline void ValueDestination::set_allocated_ref(::bc::Hash* ref) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ref_;
  }
  if (ref) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ref = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ref, submessage_arena);
    }
    
  } else {
    
  }
  ref_ = ref;
  // @@protoc_insertion_point(field_set_allocated:bc.ValueDestination.ref)
}

// .bc.AssetAmount value = 2;
inline bool ValueDestination::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void ValueDestination::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) {
    delete value_;
  }
  value_ = NULL;
}
inline const ::bc::AssetAmount& ValueDestination::value() const {
  const ::bc::AssetAmount* p = value_;
  // @@protoc_insertion_point(field_get:bc.ValueDestination.value)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::AssetAmount*>(
      &::bc::_AssetAmount_default_instance_);
}
inline ::bc::AssetAmount* ValueDestination::release_value() {
  // @@protoc_insertion_point(field_release:bc.ValueDestination.value)
  
  ::bc::AssetAmount* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::bc::AssetAmount* ValueDestination::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::bc::AssetAmount;
  }
  // @@protoc_insertion_point(field_mutable:bc.ValueDestination.value)
  return value_;
}
inline void ValueDestination::set_allocated_value(::bc::AssetAmount* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:bc.ValueDestination.value)
}

// uint64 position = 3;
inline void ValueDestination::clear_position() {
  position_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ValueDestination::position() const {
  // @@protoc_insertion_point(field_get:bc.ValueDestination.position)
  return position_;
}
inline void ValueDestination::set_position(::google::protobuf::uint64 value) {
  
  position_ = value;
  // @@protoc_insertion_point(field_set:bc.ValueDestination.position)
}

// -------------------------------------------------------------------

// BlockHeader

// uint64 version = 1;
inline void BlockHeader::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BlockHeader::version() const {
  // @@protoc_insertion_point(field_get:bc.BlockHeader.version)
  return version_;
}
inline void BlockHeader::set_version(::google::protobuf::uint64 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:bc.BlockHeader.version)
}

// uint64 height = 2;
inline void BlockHeader::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BlockHeader::height() const {
  // @@protoc_insertion_point(field_get:bc.BlockHeader.height)
  return height_;
}
inline void BlockHeader::set_height(::google::protobuf::uint64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:bc.BlockHeader.height)
}

// .bc.Hash previous_block_id = 3;
inline bool BlockHeader::has_previous_block_id() const {
  return this != internal_default_instance() && previous_block_id_ != NULL;
}
inline void BlockHeader::clear_previous_block_id() {
  if (GetArenaNoVirtual() == NULL && previous_block_id_ != NULL) {
    delete previous_block_id_;
  }
  previous_block_id_ = NULL;
}
inline const ::bc::Hash& BlockHeader::previous_block_id() const {
  const ::bc::Hash* p = previous_block_id_;
  // @@protoc_insertion_point(field_get:bc.BlockHeader.previous_block_id)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::Hash*>(
      &::bc::_Hash_default_instance_);
}
inline ::bc::Hash* BlockHeader::release_previous_block_id() {
  // @@protoc_insertion_point(field_release:bc.BlockHeader.previous_block_id)
  
  ::bc::Hash* temp = previous_block_id_;
  previous_block_id_ = NULL;
  return temp;
}
inline ::bc::Hash* BlockHeader::mutable_previous_block_id() {
  
  if (previous_block_id_ == NULL) {
    previous_block_id_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.BlockHeader.previous_block_id)
  return previous_block_id_;
}
inline void BlockHeader::set_allocated_previous_block_id(::bc::Hash* previous_block_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete previous_block_id_;
  }
  if (previous_block_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      previous_block_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, previous_block_id, submessage_arena);
    }
    
  } else {
    
  }
  previous_block_id_ = previous_block_id;
  // @@protoc_insertion_point(field_set_allocated:bc.BlockHeader.previous_block_id)
}

// uint64 timestamp = 4;
inline void BlockHeader::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BlockHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:bc.BlockHeader.timestamp)
  return timestamp_;
}
inline void BlockHeader::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:bc.BlockHeader.timestamp)
}

// .bc.Hash transactions_root = 5;
inline bool BlockHeader::has_transactions_root() const {
  return this != internal_default_instance() && transactions_root_ != NULL;
}
inline void BlockHeader::clear_transactions_root() {
  if (GetArenaNoVirtual() == NULL && transactions_root_ != NULL) {
    delete transactions_root_;
  }
  transactions_root_ = NULL;
}
inline const ::bc::Hash& BlockHeader::transactions_root() const {
  const ::bc::Hash* p = transactions_root_;
  // @@protoc_insertion_point(field_get:bc.BlockHeader.transactions_root)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::Hash*>(
      &::bc::_Hash_default_instance_);
}
inline ::bc::Hash* BlockHeader::release_transactions_root() {
  // @@protoc_insertion_point(field_release:bc.BlockHeader.transactions_root)
  
  ::bc::Hash* temp = transactions_root_;
  transactions_root_ = NULL;
  return temp;
}
inline ::bc::Hash* BlockHeader::mutable_transactions_root() {
  
  if (transactions_root_ == NULL) {
    transactions_root_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.BlockHeader.transactions_root)
  return transactions_root_;
}
inline void BlockHeader::set_allocated_transactions_root(::bc::Hash* transactions_root) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transactions_root_;
  }
  if (transactions_root) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transactions_root = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transactions_root, submessage_arena);
    }
    
  } else {
    
  }
  transactions_root_ = transactions_root;
  // @@protoc_insertion_point(field_set_allocated:bc.BlockHeader.transactions_root)
}

// .bc.Hash transaction_status_hash = 6;
inline bool BlockHeader::has_transaction_status_hash() const {
  return this != internal_default_instance() && transaction_status_hash_ != NULL;
}
inline void BlockHeader::clear_transaction_status_hash() {
  if (GetArenaNoVirtual() == NULL && transaction_status_hash_ != NULL) {
    delete transaction_status_hash_;
  }
  transaction_status_hash_ = NULL;
}
inline const ::bc::Hash& BlockHeader::transaction_status_hash() const {
  const ::bc::Hash* p = transaction_status_hash_;
  // @@protoc_insertion_point(field_get:bc.BlockHeader.transaction_status_hash)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::Hash*>(
      &::bc::_Hash_default_instance_);
}
inline ::bc::Hash* BlockHeader::release_transaction_status_hash() {
  // @@protoc_insertion_point(field_release:bc.BlockHeader.transaction_status_hash)
  
  ::bc::Hash* temp = transaction_status_hash_;
  transaction_status_hash_ = NULL;
  return temp;
}
inline ::bc::Hash* BlockHeader::mutable_transaction_status_hash() {
  
  if (transaction_status_hash_ == NULL) {
    transaction_status_hash_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.BlockHeader.transaction_status_hash)
  return transaction_status_hash_;
}
inline void BlockHeader::set_allocated_transaction_status_hash(::bc::Hash* transaction_status_hash) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transaction_status_hash_;
  }
  if (transaction_status_hash) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transaction_status_hash = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transaction_status_hash, submessage_arena);
    }
    
  } else {
    
  }
  transaction_status_hash_ = transaction_status_hash;
  // @@protoc_insertion_point(field_set_allocated:bc.BlockHeader.transaction_status_hash)
}

// uint64 nonce = 7;
inline void BlockHeader::clear_nonce() {
  nonce_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BlockHeader::nonce() const {
  // @@protoc_insertion_point(field_get:bc.BlockHeader.nonce)
  return nonce_;
}
inline void BlockHeader::set_nonce(::google::protobuf::uint64 value) {
  
  nonce_ = value;
  // @@protoc_insertion_point(field_set:bc.BlockHeader.nonce)
}

// uint64 bits = 8;
inline void BlockHeader::clear_bits() {
  bits_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BlockHeader::bits() const {
  // @@protoc_insertion_point(field_get:bc.BlockHeader.bits)
  return bits_;
}
inline void BlockHeader::set_bits(::google::protobuf::uint64 value) {
  
  bits_ = value;
  // @@protoc_insertion_point(field_set:bc.BlockHeader.bits)
}

// .bc.TransactionStatus transaction_status = 9;
inline bool BlockHeader::has_transaction_status() const {
  return this != internal_default_instance() && transaction_status_ != NULL;
}
inline void BlockHeader::clear_transaction_status() {
  if (GetArenaNoVirtual() == NULL && transaction_status_ != NULL) {
    delete transaction_status_;
  }
  transaction_status_ = NULL;
}
inline const ::bc::TransactionStatus& BlockHeader::transaction_status() const {
  const ::bc::TransactionStatus* p = transaction_status_;
  // @@protoc_insertion_point(field_get:bc.BlockHeader.transaction_status)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::TransactionStatus*>(
      &::bc::_TransactionStatus_default_instance_);
}
inline ::bc::TransactionStatus* BlockHeader::release_transaction_status() {
  // @@protoc_insertion_point(field_release:bc.BlockHeader.transaction_status)
  
  ::bc::TransactionStatus* temp = transaction_status_;
  transaction_status_ = NULL;
  return temp;
}
inline ::bc::TransactionStatus* BlockHeader::mutable_transaction_status() {
  
  if (transaction_status_ == NULL) {
    transaction_status_ = new ::bc::TransactionStatus;
  }
  // @@protoc_insertion_point(field_mutable:bc.BlockHeader.transaction_status)
  return transaction_status_;
}
inline void BlockHeader::set_allocated_transaction_status(::bc::TransactionStatus* transaction_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transaction_status_;
  }
  if (transaction_status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transaction_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transaction_status, submessage_arena);
    }
    
  } else {
    
  }
  transaction_status_ = transaction_status;
  // @@protoc_insertion_point(field_set_allocated:bc.BlockHeader.transaction_status)
}

// -------------------------------------------------------------------

// TxHeader

// uint64 version = 1;
inline void TxHeader::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TxHeader::version() const {
  // @@protoc_insertion_point(field_get:bc.TxHeader.version)
  return version_;
}
inline void TxHeader::set_version(::google::protobuf::uint64 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:bc.TxHeader.version)
}

// uint64 serialized_size = 2;
inline void TxHeader::clear_serialized_size() {
  serialized_size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TxHeader::serialized_size() const {
  // @@protoc_insertion_point(field_get:bc.TxHeader.serialized_size)
  return serialized_size_;
}
inline void TxHeader::set_serialized_size(::google::protobuf::uint64 value) {
  
  serialized_size_ = value;
  // @@protoc_insertion_point(field_set:bc.TxHeader.serialized_size)
}

// uint64 time_range = 3;
inline void TxHeader::clear_time_range() {
  time_range_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TxHeader::time_range() const {
  // @@protoc_insertion_point(field_get:bc.TxHeader.time_range)
  return time_range_;
}
inline void TxHeader::set_time_range(::google::protobuf::uint64 value) {
  
  time_range_ = value;
  // @@protoc_insertion_point(field_set:bc.TxHeader.time_range)
}

// repeated .bc.Hash result_ids = 4;
inline int TxHeader::result_ids_size() const {
  return result_ids_.size();
}
inline void TxHeader::clear_result_ids() {
  result_ids_.Clear();
}
inline const ::bc::Hash& TxHeader::result_ids(int index) const {
  // @@protoc_insertion_point(field_get:bc.TxHeader.result_ids)
  return result_ids_.Get(index);
}
inline ::bc::Hash* TxHeader::mutable_result_ids(int index) {
  // @@protoc_insertion_point(field_mutable:bc.TxHeader.result_ids)
  return result_ids_.Mutable(index);
}
inline ::bc::Hash* TxHeader::add_result_ids() {
  // @@protoc_insertion_point(field_add:bc.TxHeader.result_ids)
  return result_ids_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::bc::Hash >*
TxHeader::mutable_result_ids() {
  // @@protoc_insertion_point(field_mutable_list:bc.TxHeader.result_ids)
  return &result_ids_;
}
inline const ::google::protobuf::RepeatedPtrField< ::bc::Hash >&
TxHeader::result_ids() const {
  // @@protoc_insertion_point(field_list:bc.TxHeader.result_ids)
  return result_ids_;
}

// -------------------------------------------------------------------

// TxVerifyResult

// bool status_fail = 1;
inline void TxVerifyResult::clear_status_fail() {
  status_fail_ = false;
}
inline bool TxVerifyResult::status_fail() const {
  // @@protoc_insertion_point(field_get:bc.TxVerifyResult.status_fail)
  return status_fail_;
}
inline void TxVerifyResult::set_status_fail(bool value) {
  
  status_fail_ = value;
  // @@protoc_insertion_point(field_set:bc.TxVerifyResult.status_fail)
}

// -------------------------------------------------------------------

// TransactionStatus

// uint64 version = 1;
inline void TransactionStatus::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TransactionStatus::version() const {
  // @@protoc_insertion_point(field_get:bc.TransactionStatus.version)
  return version_;
}
inline void TransactionStatus::set_version(::google::protobuf::uint64 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:bc.TransactionStatus.version)
}

// repeated .bc.TxVerifyResult verify_status = 2;
inline int TransactionStatus::verify_status_size() const {
  return verify_status_.size();
}
inline void TransactionStatus::clear_verify_status() {
  verify_status_.Clear();
}
inline const ::bc::TxVerifyResult& TransactionStatus::verify_status(int index) const {
  // @@protoc_insertion_point(field_get:bc.TransactionStatus.verify_status)
  return verify_status_.Get(index);
}
inline ::bc::TxVerifyResult* TransactionStatus::mutable_verify_status(int index) {
  // @@protoc_insertion_point(field_mutable:bc.TransactionStatus.verify_status)
  return verify_status_.Mutable(index);
}
inline ::bc::TxVerifyResult* TransactionStatus::add_verify_status() {
  // @@protoc_insertion_point(field_add:bc.TransactionStatus.verify_status)
  return verify_status_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::bc::TxVerifyResult >*
TransactionStatus::mutable_verify_status() {
  // @@protoc_insertion_point(field_mutable_list:bc.TransactionStatus.verify_status)
  return &verify_status_;
}
inline const ::google::protobuf::RepeatedPtrField< ::bc::TxVerifyResult >&
TransactionStatus::verify_status() const {
  // @@protoc_insertion_point(field_list:bc.TransactionStatus.verify_status)
  return verify_status_;
}

// -------------------------------------------------------------------

// Mux

// repeated .bc.ValueSource sources = 1;
inline int Mux::sources_size() const {
  return sources_.size();
}
inline void Mux::clear_sources() {
  sources_.Clear();
}
inline const ::bc::ValueSource& Mux::sources(int index) const {
  // @@protoc_insertion_point(field_get:bc.Mux.sources)
  return sources_.Get(index);
}
inline ::bc::ValueSource* Mux::mutable_sources(int index) {
  // @@protoc_insertion_point(field_mutable:bc.Mux.sources)
  return sources_.Mutable(index);
}
inline ::bc::ValueSource* Mux::add_sources() {
  // @@protoc_insertion_point(field_add:bc.Mux.sources)
  return sources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::bc::ValueSource >*
Mux::mutable_sources() {
  // @@protoc_insertion_point(field_mutable_list:bc.Mux.sources)
  return &sources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::bc::ValueSource >&
Mux::sources() const {
  // @@protoc_insertion_point(field_list:bc.Mux.sources)
  return sources_;
}

// .bc.Program program = 2;
inline bool Mux::has_program() const {
  return this != internal_default_instance() && program_ != NULL;
}
inline void Mux::clear_program() {
  if (GetArenaNoVirtual() == NULL && program_ != NULL) {
    delete program_;
  }
  program_ = NULL;
}
inline const ::bc::Program& Mux::program() const {
  const ::bc::Program* p = program_;
  // @@protoc_insertion_point(field_get:bc.Mux.program)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::Program*>(
      &::bc::_Program_default_instance_);
}
inline ::bc::Program* Mux::release_program() {
  // @@protoc_insertion_point(field_release:bc.Mux.program)
  
  ::bc::Program* temp = program_;
  program_ = NULL;
  return temp;
}
inline ::bc::Program* Mux::mutable_program() {
  
  if (program_ == NULL) {
    program_ = new ::bc::Program;
  }
  // @@protoc_insertion_point(field_mutable:bc.Mux.program)
  return program_;
}
inline void Mux::set_allocated_program(::bc::Program* program) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete program_;
  }
  if (program) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      program = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, program, submessage_arena);
    }
    
  } else {
    
  }
  program_ = program;
  // @@protoc_insertion_point(field_set_allocated:bc.Mux.program)
}

// repeated .bc.ValueDestination witness_destinations = 3;
inline int Mux::witness_destinations_size() const {
  return witness_destinations_.size();
}
inline void Mux::clear_witness_destinations() {
  witness_destinations_.Clear();
}
inline const ::bc::ValueDestination& Mux::witness_destinations(int index) const {
  // @@protoc_insertion_point(field_get:bc.Mux.witness_destinations)
  return witness_destinations_.Get(index);
}
inline ::bc::ValueDestination* Mux::mutable_witness_destinations(int index) {
  // @@protoc_insertion_point(field_mutable:bc.Mux.witness_destinations)
  return witness_destinations_.Mutable(index);
}
inline ::bc::ValueDestination* Mux::add_witness_destinations() {
  // @@protoc_insertion_point(field_add:bc.Mux.witness_destinations)
  return witness_destinations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::bc::ValueDestination >*
Mux::mutable_witness_destinations() {
  // @@protoc_insertion_point(field_mutable_list:bc.Mux.witness_destinations)
  return &witness_destinations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::bc::ValueDestination >&
Mux::witness_destinations() const {
  // @@protoc_insertion_point(field_list:bc.Mux.witness_destinations)
  return witness_destinations_;
}

// repeated bytes witness_arguments = 4;
inline int Mux::witness_arguments_size() const {
  return witness_arguments_.size();
}
inline void Mux::clear_witness_arguments() {
  witness_arguments_.Clear();
}
inline const ::std::string& Mux::witness_arguments(int index) const {
  // @@protoc_insertion_point(field_get:bc.Mux.witness_arguments)
  return witness_arguments_.Get(index);
}
inline ::std::string* Mux::mutable_witness_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:bc.Mux.witness_arguments)
  return witness_arguments_.Mutable(index);
}
inline void Mux::set_witness_arguments(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:bc.Mux.witness_arguments)
  witness_arguments_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Mux::set_witness_arguments(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:bc.Mux.witness_arguments)
  witness_arguments_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Mux::set_witness_arguments(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  witness_arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bc.Mux.witness_arguments)
}
inline void Mux::set_witness_arguments(int index, const void* value, size_t size) {
  witness_arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bc.Mux.witness_arguments)
}
inline ::std::string* Mux::add_witness_arguments() {
  // @@protoc_insertion_point(field_add_mutable:bc.Mux.witness_arguments)
  return witness_arguments_.Add();
}
inline void Mux::add_witness_arguments(const ::std::string& value) {
  witness_arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bc.Mux.witness_arguments)
}
#if LANG_CXX11
inline void Mux::add_witness_arguments(::std::string&& value) {
  witness_arguments_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bc.Mux.witness_arguments)
}
#endif
inline void Mux::add_witness_arguments(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  witness_arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bc.Mux.witness_arguments)
}
inline void Mux::add_witness_arguments(const void* value, size_t size) {
  witness_arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bc.Mux.witness_arguments)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Mux::witness_arguments() const {
  // @@protoc_insertion_point(field_list:bc.Mux.witness_arguments)
  return witness_arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Mux::mutable_witness_arguments() {
  // @@protoc_insertion_point(field_mutable_list:bc.Mux.witness_arguments)
  return &witness_arguments_;
}

// -------------------------------------------------------------------

// Coinbase

// .bc.ValueDestination witness_destination = 1;
inline bool Coinbase::has_witness_destination() const {
  return this != internal_default_instance() && witness_destination_ != NULL;
}
inline void Coinbase::clear_witness_destination() {
  if (GetArenaNoVirtual() == NULL && witness_destination_ != NULL) {
    delete witness_destination_;
  }
  witness_destination_ = NULL;
}
inline const ::bc::ValueDestination& Coinbase::witness_destination() const {
  const ::bc::ValueDestination* p = witness_destination_;
  // @@protoc_insertion_point(field_get:bc.Coinbase.witness_destination)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::ValueDestination*>(
      &::bc::_ValueDestination_default_instance_);
}
inline ::bc::ValueDestination* Coinbase::release_witness_destination() {
  // @@protoc_insertion_point(field_release:bc.Coinbase.witness_destination)
  
  ::bc::ValueDestination* temp = witness_destination_;
  witness_destination_ = NULL;
  return temp;
}
inline ::bc::ValueDestination* Coinbase::mutable_witness_destination() {
  
  if (witness_destination_ == NULL) {
    witness_destination_ = new ::bc::ValueDestination;
  }
  // @@protoc_insertion_point(field_mutable:bc.Coinbase.witness_destination)
  return witness_destination_;
}
inline void Coinbase::set_allocated_witness_destination(::bc::ValueDestination* witness_destination) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete witness_destination_;
  }
  if (witness_destination) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      witness_destination = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, witness_destination, submessage_arena);
    }
    
  } else {
    
  }
  witness_destination_ = witness_destination;
  // @@protoc_insertion_point(field_set_allocated:bc.Coinbase.witness_destination)
}

// bytes arbitrary = 2;
inline void Coinbase::clear_arbitrary() {
  arbitrary_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Coinbase::arbitrary() const {
  // @@protoc_insertion_point(field_get:bc.Coinbase.arbitrary)
  return arbitrary_.GetNoArena();
}
inline void Coinbase::set_arbitrary(const ::std::string& value) {
  
  arbitrary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bc.Coinbase.arbitrary)
}
#if LANG_CXX11
inline void Coinbase::set_arbitrary(::std::string&& value) {
  
  arbitrary_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bc.Coinbase.arbitrary)
}
#endif
inline void Coinbase::set_arbitrary(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  arbitrary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bc.Coinbase.arbitrary)
}
inline void Coinbase::set_arbitrary(const void* value, size_t size) {
  
  arbitrary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bc.Coinbase.arbitrary)
}
inline ::std::string* Coinbase::mutable_arbitrary() {
  
  // @@protoc_insertion_point(field_mutable:bc.Coinbase.arbitrary)
  return arbitrary_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Coinbase::release_arbitrary() {
  // @@protoc_insertion_point(field_release:bc.Coinbase.arbitrary)
  
  return arbitrary_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Coinbase::set_allocated_arbitrary(::std::string* arbitrary) {
  if (arbitrary != NULL) {
    
  } else {
    
  }
  arbitrary_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), arbitrary);
  // @@protoc_insertion_point(field_set_allocated:bc.Coinbase.arbitrary)
}

// -------------------------------------------------------------------

// Output

// .bc.ValueSource source = 1;
inline bool Output::has_source() const {
  return this != internal_default_instance() && source_ != NULL;
}
inline void Output::clear_source() {
  if (GetArenaNoVirtual() == NULL && source_ != NULL) {
    delete source_;
  }
  source_ = NULL;
}
inline const ::bc::ValueSource& Output::source() const {
  const ::bc::ValueSource* p = source_;
  // @@protoc_insertion_point(field_get:bc.Output.source)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::ValueSource*>(
      &::bc::_ValueSource_default_instance_);
}
inline ::bc::ValueSource* Output::release_source() {
  // @@protoc_insertion_point(field_release:bc.Output.source)
  
  ::bc::ValueSource* temp = source_;
  source_ = NULL;
  return temp;
}
inline ::bc::ValueSource* Output::mutable_source() {
  
  if (source_ == NULL) {
    source_ = new ::bc::ValueSource;
  }
  // @@protoc_insertion_point(field_mutable:bc.Output.source)
  return source_;
}
inline void Output::set_allocated_source(::bc::ValueSource* source) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_;
  }
  if (source) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:bc.Output.source)
}

// .bc.Program control_program = 2;
inline bool Output::has_control_program() const {
  return this != internal_default_instance() && control_program_ != NULL;
}
inline void Output::clear_control_program() {
  if (GetArenaNoVirtual() == NULL && control_program_ != NULL) {
    delete control_program_;
  }
  control_program_ = NULL;
}
inline const ::bc::Program& Output::control_program() const {
  const ::bc::Program* p = control_program_;
  // @@protoc_insertion_point(field_get:bc.Output.control_program)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::Program*>(
      &::bc::_Program_default_instance_);
}
inline ::bc::Program* Output::release_control_program() {
  // @@protoc_insertion_point(field_release:bc.Output.control_program)
  
  ::bc::Program* temp = control_program_;
  control_program_ = NULL;
  return temp;
}
inline ::bc::Program* Output::mutable_control_program() {
  
  if (control_program_ == NULL) {
    control_program_ = new ::bc::Program;
  }
  // @@protoc_insertion_point(field_mutable:bc.Output.control_program)
  return control_program_;
}
inline void Output::set_allocated_control_program(::bc::Program* control_program) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete control_program_;
  }
  if (control_program) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      control_program = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, control_program, submessage_arena);
    }
    
  } else {
    
  }
  control_program_ = control_program;
  // @@protoc_insertion_point(field_set_allocated:bc.Output.control_program)
}

// uint64 ordinal = 3;
inline void Output::clear_ordinal() {
  ordinal_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Output::ordinal() const {
  // @@protoc_insertion_point(field_get:bc.Output.ordinal)
  return ordinal_;
}
inline void Output::set_ordinal(::google::protobuf::uint64 value) {
  
  ordinal_ = value;
  // @@protoc_insertion_point(field_set:bc.Output.ordinal)
}

// -------------------------------------------------------------------

// Retirement

// .bc.ValueSource source = 1;
inline bool Retirement::has_source() const {
  return this != internal_default_instance() && source_ != NULL;
}
inline void Retirement::clear_source() {
  if (GetArenaNoVirtual() == NULL && source_ != NULL) {
    delete source_;
  }
  source_ = NULL;
}
inline const ::bc::ValueSource& Retirement::source() const {
  const ::bc::ValueSource* p = source_;
  // @@protoc_insertion_point(field_get:bc.Retirement.source)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::ValueSource*>(
      &::bc::_ValueSource_default_instance_);
}
inline ::bc::ValueSource* Retirement::release_source() {
  // @@protoc_insertion_point(field_release:bc.Retirement.source)
  
  ::bc::ValueSource* temp = source_;
  source_ = NULL;
  return temp;
}
inline ::bc::ValueSource* Retirement::mutable_source() {
  
  if (source_ == NULL) {
    source_ = new ::bc::ValueSource;
  }
  // @@protoc_insertion_point(field_mutable:bc.Retirement.source)
  return source_;
}
inline void Retirement::set_allocated_source(::bc::ValueSource* source) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_;
  }
  if (source) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:bc.Retirement.source)
}

// uint64 ordinal = 2;
inline void Retirement::clear_ordinal() {
  ordinal_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Retirement::ordinal() const {
  // @@protoc_insertion_point(field_get:bc.Retirement.ordinal)
  return ordinal_;
}
inline void Retirement::set_ordinal(::google::protobuf::uint64 value) {
  
  ordinal_ = value;
  // @@protoc_insertion_point(field_set:bc.Retirement.ordinal)
}

// -------------------------------------------------------------------

// Issuance

// .bc.Hash nonce_hash = 1;
inline bool Issuance::has_nonce_hash() const {
  return this != internal_default_instance() && nonce_hash_ != NULL;
}
inline void Issuance::clear_nonce_hash() {
  if (GetArenaNoVirtual() == NULL && nonce_hash_ != NULL) {
    delete nonce_hash_;
  }
  nonce_hash_ = NULL;
}
inline const ::bc::Hash& Issuance::nonce_hash() const {
  const ::bc::Hash* p = nonce_hash_;
  // @@protoc_insertion_point(field_get:bc.Issuance.nonce_hash)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::Hash*>(
      &::bc::_Hash_default_instance_);
}
inline ::bc::Hash* Issuance::release_nonce_hash() {
  // @@protoc_insertion_point(field_release:bc.Issuance.nonce_hash)
  
  ::bc::Hash* temp = nonce_hash_;
  nonce_hash_ = NULL;
  return temp;
}
inline ::bc::Hash* Issuance::mutable_nonce_hash() {
  
  if (nonce_hash_ == NULL) {
    nonce_hash_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.Issuance.nonce_hash)
  return nonce_hash_;
}
inline void Issuance::set_allocated_nonce_hash(::bc::Hash* nonce_hash) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete nonce_hash_;
  }
  if (nonce_hash) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      nonce_hash = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, nonce_hash, submessage_arena);
    }
    
  } else {
    
  }
  nonce_hash_ = nonce_hash;
  // @@protoc_insertion_point(field_set_allocated:bc.Issuance.nonce_hash)
}

// .bc.AssetAmount value = 2;
inline bool Issuance::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void Issuance::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) {
    delete value_;
  }
  value_ = NULL;
}
inline const ::bc::AssetAmount& Issuance::value() const {
  const ::bc::AssetAmount* p = value_;
  // @@protoc_insertion_point(field_get:bc.Issuance.value)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::AssetAmount*>(
      &::bc::_AssetAmount_default_instance_);
}
inline ::bc::AssetAmount* Issuance::release_value() {
  // @@protoc_insertion_point(field_release:bc.Issuance.value)
  
  ::bc::AssetAmount* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::bc::AssetAmount* Issuance::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::bc::AssetAmount;
  }
  // @@protoc_insertion_point(field_mutable:bc.Issuance.value)
  return value_;
}
inline void Issuance::set_allocated_value(::bc::AssetAmount* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:bc.Issuance.value)
}

// .bc.ValueDestination witness_destination = 3;
inline bool Issuance::has_witness_destination() const {
  return this != internal_default_instance() && witness_destination_ != NULL;
}
inline void Issuance::clear_witness_destination() {
  if (GetArenaNoVirtual() == NULL && witness_destination_ != NULL) {
    delete witness_destination_;
  }
  witness_destination_ = NULL;
}
inline const ::bc::ValueDestination& Issuance::witness_destination() const {
  const ::bc::ValueDestination* p = witness_destination_;
  // @@protoc_insertion_point(field_get:bc.Issuance.witness_destination)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::ValueDestination*>(
      &::bc::_ValueDestination_default_instance_);
}
inline ::bc::ValueDestination* Issuance::release_witness_destination() {
  // @@protoc_insertion_point(field_release:bc.Issuance.witness_destination)
  
  ::bc::ValueDestination* temp = witness_destination_;
  witness_destination_ = NULL;
  return temp;
}
inline ::bc::ValueDestination* Issuance::mutable_witness_destination() {
  
  if (witness_destination_ == NULL) {
    witness_destination_ = new ::bc::ValueDestination;
  }
  // @@protoc_insertion_point(field_mutable:bc.Issuance.witness_destination)
  return witness_destination_;
}
inline void Issuance::set_allocated_witness_destination(::bc::ValueDestination* witness_destination) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete witness_destination_;
  }
  if (witness_destination) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      witness_destination = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, witness_destination, submessage_arena);
    }
    
  } else {
    
  }
  witness_destination_ = witness_destination;
  // @@protoc_insertion_point(field_set_allocated:bc.Issuance.witness_destination)
}

// .bc.AssetDefinition witness_asset_definition = 4;
inline bool Issuance::has_witness_asset_definition() const {
  return this != internal_default_instance() && witness_asset_definition_ != NULL;
}
inline void Issuance::clear_witness_asset_definition() {
  if (GetArenaNoVirtual() == NULL && witness_asset_definition_ != NULL) {
    delete witness_asset_definition_;
  }
  witness_asset_definition_ = NULL;
}
inline const ::bc::AssetDefinition& Issuance::witness_asset_definition() const {
  const ::bc::AssetDefinition* p = witness_asset_definition_;
  // @@protoc_insertion_point(field_get:bc.Issuance.witness_asset_definition)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::AssetDefinition*>(
      &::bc::_AssetDefinition_default_instance_);
}
inline ::bc::AssetDefinition* Issuance::release_witness_asset_definition() {
  // @@protoc_insertion_point(field_release:bc.Issuance.witness_asset_definition)
  
  ::bc::AssetDefinition* temp = witness_asset_definition_;
  witness_asset_definition_ = NULL;
  return temp;
}
inline ::bc::AssetDefinition* Issuance::mutable_witness_asset_definition() {
  
  if (witness_asset_definition_ == NULL) {
    witness_asset_definition_ = new ::bc::AssetDefinition;
  }
  // @@protoc_insertion_point(field_mutable:bc.Issuance.witness_asset_definition)
  return witness_asset_definition_;
}
inline void Issuance::set_allocated_witness_asset_definition(::bc::AssetDefinition* witness_asset_definition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete witness_asset_definition_;
  }
  if (witness_asset_definition) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      witness_asset_definition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, witness_asset_definition, submessage_arena);
    }
    
  } else {
    
  }
  witness_asset_definition_ = witness_asset_definition;
  // @@protoc_insertion_point(field_set_allocated:bc.Issuance.witness_asset_definition)
}

// repeated bytes witness_arguments = 5;
inline int Issuance::witness_arguments_size() const {
  return witness_arguments_.size();
}
inline void Issuance::clear_witness_arguments() {
  witness_arguments_.Clear();
}
inline const ::std::string& Issuance::witness_arguments(int index) const {
  // @@protoc_insertion_point(field_get:bc.Issuance.witness_arguments)
  return witness_arguments_.Get(index);
}
inline ::std::string* Issuance::mutable_witness_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:bc.Issuance.witness_arguments)
  return witness_arguments_.Mutable(index);
}
inline void Issuance::set_witness_arguments(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:bc.Issuance.witness_arguments)
  witness_arguments_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Issuance::set_witness_arguments(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:bc.Issuance.witness_arguments)
  witness_arguments_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Issuance::set_witness_arguments(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  witness_arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bc.Issuance.witness_arguments)
}
inline void Issuance::set_witness_arguments(int index, const void* value, size_t size) {
  witness_arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bc.Issuance.witness_arguments)
}
inline ::std::string* Issuance::add_witness_arguments() {
  // @@protoc_insertion_point(field_add_mutable:bc.Issuance.witness_arguments)
  return witness_arguments_.Add();
}
inline void Issuance::add_witness_arguments(const ::std::string& value) {
  witness_arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bc.Issuance.witness_arguments)
}
#if LANG_CXX11
inline void Issuance::add_witness_arguments(::std::string&& value) {
  witness_arguments_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bc.Issuance.witness_arguments)
}
#endif
inline void Issuance::add_witness_arguments(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  witness_arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bc.Issuance.witness_arguments)
}
inline void Issuance::add_witness_arguments(const void* value, size_t size) {
  witness_arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bc.Issuance.witness_arguments)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Issuance::witness_arguments() const {
  // @@protoc_insertion_point(field_list:bc.Issuance.witness_arguments)
  return witness_arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Issuance::mutable_witness_arguments() {
  // @@protoc_insertion_point(field_mutable_list:bc.Issuance.witness_arguments)
  return &witness_arguments_;
}

// uint64 ordinal = 6;
inline void Issuance::clear_ordinal() {
  ordinal_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Issuance::ordinal() const {
  // @@protoc_insertion_point(field_get:bc.Issuance.ordinal)
  return ordinal_;
}
inline void Issuance::set_ordinal(::google::protobuf::uint64 value) {
  
  ordinal_ = value;
  // @@protoc_insertion_point(field_set:bc.Issuance.ordinal)
}

// -------------------------------------------------------------------

// Spend

// .bc.Hash spent_output_id = 1;
inline bool Spend::has_spent_output_id() const {
  return this != internal_default_instance() && spent_output_id_ != NULL;
}
inline void Spend::clear_spent_output_id() {
  if (GetArenaNoVirtual() == NULL && spent_output_id_ != NULL) {
    delete spent_output_id_;
  }
  spent_output_id_ = NULL;
}
inline const ::bc::Hash& Spend::spent_output_id() const {
  const ::bc::Hash* p = spent_output_id_;
  // @@protoc_insertion_point(field_get:bc.Spend.spent_output_id)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::Hash*>(
      &::bc::_Hash_default_instance_);
}
inline ::bc::Hash* Spend::release_spent_output_id() {
  // @@protoc_insertion_point(field_release:bc.Spend.spent_output_id)
  
  ::bc::Hash* temp = spent_output_id_;
  spent_output_id_ = NULL;
  return temp;
}
inline ::bc::Hash* Spend::mutable_spent_output_id() {
  
  if (spent_output_id_ == NULL) {
    spent_output_id_ = new ::bc::Hash;
  }
  // @@protoc_insertion_point(field_mutable:bc.Spend.spent_output_id)
  return spent_output_id_;
}
inline void Spend::set_allocated_spent_output_id(::bc::Hash* spent_output_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete spent_output_id_;
  }
  if (spent_output_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      spent_output_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, spent_output_id, submessage_arena);
    }
    
  } else {
    
  }
  spent_output_id_ = spent_output_id;
  // @@protoc_insertion_point(field_set_allocated:bc.Spend.spent_output_id)
}

// .bc.ValueDestination witness_destination = 2;
inline bool Spend::has_witness_destination() const {
  return this != internal_default_instance() && witness_destination_ != NULL;
}
inline void Spend::clear_witness_destination() {
  if (GetArenaNoVirtual() == NULL && witness_destination_ != NULL) {
    delete witness_destination_;
  }
  witness_destination_ = NULL;
}
inline const ::bc::ValueDestination& Spend::witness_destination() const {
  const ::bc::ValueDestination* p = witness_destination_;
  // @@protoc_insertion_point(field_get:bc.Spend.witness_destination)
  return p != NULL ? *p : *reinterpret_cast<const ::bc::ValueDestination*>(
      &::bc::_ValueDestination_default_instance_);
}
inline ::bc::ValueDestination* Spend::release_witness_destination() {
  // @@protoc_insertion_point(field_release:bc.Spend.witness_destination)
  
  ::bc::ValueDestination* temp = witness_destination_;
  witness_destination_ = NULL;
  return temp;
}
inline ::bc::ValueDestination* Spend::mutable_witness_destination() {
  
  if (witness_destination_ == NULL) {
    witness_destination_ = new ::bc::ValueDestination;
  }
  // @@protoc_insertion_point(field_mutable:bc.Spend.witness_destination)
  return witness_destination_;
}
inline void Spend::set_allocated_witness_destination(::bc::ValueDestination* witness_destination) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete witness_destination_;
  }
  if (witness_destination) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      witness_destination = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, witness_destination, submessage_arena);
    }
    
  } else {
    
  }
  witness_destination_ = witness_destination;
  // @@protoc_insertion_point(field_set_allocated:bc.Spend.witness_destination)
}

// repeated bytes witness_arguments = 3;
inline int Spend::witness_arguments_size() const {
  return witness_arguments_.size();
}
inline void Spend::clear_witness_arguments() {
  witness_arguments_.Clear();
}
inline const ::std::string& Spend::witness_arguments(int index) const {
  // @@protoc_insertion_point(field_get:bc.Spend.witness_arguments)
  return witness_arguments_.Get(index);
}
inline ::std::string* Spend::mutable_witness_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:bc.Spend.witness_arguments)
  return witness_arguments_.Mutable(index);
}
inline void Spend::set_witness_arguments(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:bc.Spend.witness_arguments)
  witness_arguments_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Spend::set_witness_arguments(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:bc.Spend.witness_arguments)
  witness_arguments_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Spend::set_witness_arguments(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  witness_arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bc.Spend.witness_arguments)
}
inline void Spend::set_witness_arguments(int index, const void* value, size_t size) {
  witness_arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bc.Spend.witness_arguments)
}
inline ::std::string* Spend::add_witness_arguments() {
  // @@protoc_insertion_point(field_add_mutable:bc.Spend.witness_arguments)
  return witness_arguments_.Add();
}
inline void Spend::add_witness_arguments(const ::std::string& value) {
  witness_arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bc.Spend.witness_arguments)
}
#if LANG_CXX11
inline void Spend::add_witness_arguments(::std::string&& value) {
  witness_arguments_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bc.Spend.witness_arguments)
}
#endif
inline void Spend::add_witness_arguments(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  witness_arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bc.Spend.witness_arguments)
}
inline void Spend::add_witness_arguments(const void* value, size_t size) {
  witness_arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bc.Spend.witness_arguments)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Spend::witness_arguments() const {
  // @@protoc_insertion_point(field_list:bc.Spend.witness_arguments)
  return witness_arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Spend::mutable_witness_arguments() {
  // @@protoc_insertion_point(field_mutable_list:bc.Spend.witness_arguments)
  return &witness_arguments_;
}

// uint64 ordinal = 4;
inline void Spend::clear_ordinal() {
  ordinal_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Spend::ordinal() const {
  // @@protoc_insertion_point(field_get:bc.Spend.ordinal)
  return ordinal_;
}
inline void Spend::set_ordinal(::google::protobuf::uint64 value) {
  
  ordinal_ = value;
  // @@protoc_insertion_point(field_set:bc.Spend.ordinal)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace bc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_bc_2eproto__INCLUDED
